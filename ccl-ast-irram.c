
#include "ccl.h"

#define IRRAM_HEADER "\n\
/* generated by ccl v" CCL_VERSION_STR " */\n\
\n\
#include <iRRAM.h>\n\
"

static const char *const CCLERICAL_iRRAM_TYPES[] = {
	[CCLERICAL_TYPE_UNIT] = "void",
	[CCLERICAL_TYPE_BOOL] = "bool",
	[CCLERICAL_TYPE_INT ] = "iRRAM::INTEGER",
	[CCLERICAL_TYPE_REAL] = "iRRAM::REAL",
};

static const char *const CCLERICAL_CPP_UOPS[] = {
	[CCLERICAL_OP_NEG] = "-",
	[CCLERICAL_OP_NOT] = "!",
};

static const char *const CCLERICAL_CPP_BOPS[] = {
	[CCLERICAL_OP_ADD] = "+",
	[CCLERICAL_OP_SUB] = "-",
	[CCLERICAL_OP_MUL] = "*",
	[CCLERICAL_OP_DIV] = "/",
	[CCLERICAL_OP_EXP] = NULL,
	[CCLERICAL_OP_LT]  = "<",
	[CCLERICAL_OP_LE]  = "<=",
	[CCLERICAL_OP_GT]  = ">",
	[CCLERICAL_OP_GE]  = ">=",
	[CCLERICAL_OP_NE]  = "!=",
	[CCLERICAL_OP_EQ]  = "==",
};

typedef ccl_vec_t vec_t;

static void export_irram_var_decl(FILE *out,
                                  const struct cclerical_vec_decl_ptr *decls,
                                  cclerical_id_t ai, int const_ref)
{
	struct cclerical_decl *a = decls->data[ai];
	fprintf(out, "%s%s %s%s%zu /* clerical: %s */",
	        const_ref ? "const " : "", CCLERICAL_iRRAM_TYPES[a->value_type],
	        const_ref ? "&" : "", CCL_PREFIX, ai, a->id);
}

static void export_irram_fun_sig(FILE *out,
                                 const struct cclerical_vec_decl_ptr *decls,
                                 cclerical_id_t i)
{
	struct cclerical_decl *d = decls->data[i];
	if (!cclerical_decl_fun_is_external(d)) {
		fprintf(out, "static %s %s%zu(",
		       CCLERICAL_iRRAM_TYPES[d->value_type], CCL_PREFIX, i);
		const struct cclerical_vec_id_t *args = &d->fun.arguments.ids;
		for (size_t j=0; j<args->valid; j++) {
			cclerical_id_t ai = args->data[j];
			export_irram_var_decl(out, decls, ai, 0);
			if (j+1 < args->valid)
				fprintf(out, ", ");
		}
		fprintf(out, ")");
	} else {
		fprintf(out, "%s %s(", CCLERICAL_iRRAM_TYPES[d->value_type], d->id);
		const struct cclerical_vec_type *args = &d->fun.arguments.types;
		for (size_t j=0; j<args->valid; j++) {
			enum cclerical_type t = args->data[j];
			fprintf(out, "%s%s", j ? ", " : "", CCLERICAL_iRRAM_TYPES[t]);
		}
		fprintf(out, ")");
	}
}

static void export_irram_fun_decl(FILE *out,
                                  const struct cclerical_vec_decl_ptr *decls,
                                  cclerical_id_t i)
{
	struct cclerical_decl *d = decls->data[i];
	if (!cclerical_decl_fun_is_external(d)) {
		fprintf(out, "/* clerical fun: %s */\n", d->id);
	} else {
		fprintf(out, "/* clerical external fun #%zu: %s */\n", i, d->id);
		fprintf(out, "namespace cclerical {\n");
	}
	export_irram_fun_sig(out, decls, i);
	fprintf(out, ";\n");
	if (cclerical_decl_fun_is_external(d))
		fprintf(out, "}\n");
}

enum var_access {
	VAR_ACCESS_RO,
	VAR_ACCESS_RW,
	VAR_ACCESS_DEF,
	VAR_ACCESS_CALL,
};

typedef void visit_varrefs_f(const struct cclerical_vec_decl_ptr *decls,
                             cclerical_id_t v,
                             enum var_access access, void *cb_data);

static void visit_varrefs_prog(const struct cclerical_vec_decl_ptr *decls,
                               const struct cclerical_prog *p,
                               visit_varrefs_f *visit, void *cb_data);

static void visit_varrefs_expr(const struct cclerical_vec_decl_ptr *decls,
                               const struct cclerical_expr *e,
                               visit_varrefs_f *visit, void *cb_data)
{
	switch (e->type) {
	case CCLERICAL_EXPR_CASE:
		for (size_t i=0; i<e->cases.valid; i++) {
			visit_varrefs_expr(decls, e->cases.data[i].cond, visit, cb_data);
			visit_varrefs_expr(decls, e->cases.data[i].body, visit, cb_data);
		}
		break;
	case CCLERICAL_EXPR_IF:
		visit_varrefs_expr(decls, e->branch.cond, visit, cb_data);
		visit_varrefs_expr(decls, e->branch.if_true, visit, cb_data);
		if (e->branch.if_false)
			visit_varrefs_expr(decls, e->branch.if_false, visit, cb_data);
		break;
	case CCLERICAL_EXPR_CNST:
		break;
	case CCLERICAL_EXPR_DECL_ASGN:
		for (size_t i=0; i<e->decl_asgn.inits.valid; i++) {
			const struct cclerical_decl_asgn *da
				= &e->decl_asgn.inits.data[i];
			visit(decls, da->id, VAR_ACCESS_DEF, cb_data);
			visit_varrefs_expr(decls, da->init, visit, cb_data);
		}
		visit_varrefs_expr(decls, e->decl_asgn.body, visit, cb_data);
		break;
	case CCLERICAL_EXPR_FUN_CALL:
		visit(decls, e->fun_call.fun, VAR_ACCESS_CALL, cb_data);
		for (size_t i=0; i<e->fun_call.params.valid; i++)
			visit_varrefs_expr(decls, e->fun_call.params.data[i], visit, cb_data);
		break;
	case CCLERICAL_EXPR_LIM:
		visit(decls, e->lim.seq_idx, VAR_ACCESS_DEF, cb_data);
		visit_varrefs_expr(decls, e->lim.seq, visit, cb_data);
		break;
	case CCLERICAL_EXPR_OP:
		for (unsigned i=0; i<cclerical_op_arity(e->op.op); i++)
			visit_varrefs_expr(decls, e->op.args[i], visit, cb_data);
		break;
	case CCLERICAL_EXPR_VAR:
		visit(decls, e->var, VAR_ACCESS_RO, cb_data);
		break;
	case CCLERICAL_EXPR_ASGN:
		visit(decls, e->asgn.var, VAR_ACCESS_RW, cb_data);
		visit_varrefs_expr(decls, e->asgn.expr, visit, cb_data);
		break;
	case CCLERICAL_EXPR_SKIP:
		break;
	case CCLERICAL_EXPR_WHILE:
		visit_varrefs_expr(decls, e->loop.cond, visit, cb_data);
		visit_varrefs_expr(decls, e->loop.body, visit, cb_data);
		break;
	case CCLERICAL_EXPR_SEQ:
		visit_varrefs_prog(decls, e->seq, visit, cb_data);
		break;
	}
}

static void visit_varrefs_prog(const struct cclerical_vec_decl_ptr *decls,
                               const struct cclerical_prog *p,
                               visit_varrefs_f *visit, void *cb_data)
{
	for (size_t i=0; i<p->exprs.valid; i++) {
		const struct cclerical_expr *e = p->exprs.data[i];
		visit_varrefs_expr(decls, e, visit, cb_data);
	}
}

static void export_irram_prog(FILE *out,
                              const struct cclerical_vec_decl_ptr *decls,
                              const struct cclerical_prog *p, int lvl);

struct visit_prev_scope_args {
	vec_t *vars;
	cclerical_id_t up_excl;
};

static void visit_prev_scope(const struct cclerical_vec_decl_ptr *decls,
                             cclerical_id_t v,
                             enum var_access access, void *cb_data)
{
	struct visit_prev_scope_args *a = cb_data;
	(void)decls;
	(void)access;
	if (v >= a->up_excl || access != VAR_ACCESS_RO)
		return;
	for (size_t i=0; i<a->vars->valid; i++)
		if ((uintptr_t)a->vars->data[i] == v)
			return;
	cclerical_vector_add(a->vars, (void *)(uintptr_t)v);
}

static void export_irram_expr(FILE *out,
                              const struct cclerical_vec_decl_ptr *decls,
                              const struct cclerical_expr *e, int lvl)
{
	switch (e->type) {
	case CCLERICAL_EXPR_CNST:
		switch (e->cnst.type) {
		case CCLERICAL_TYPE_UNIT:
			abort();
		case CCLERICAL_TYPE_BOOL:
			cclprintf(out, 0, "%s", e->cnst.boolean ? "true" : "false");
			break;
		case CCLERICAL_TYPE_INT:
		case CCLERICAL_TYPE_REAL:
			cclprintf(out, 0, "%s(\"%s\")",
			          CCLERICAL_iRRAM_TYPES[e->cnst.type],
			          e->cnst.numeric.str);
			break;
		}
		break;
	case CCLERICAL_EXPR_DECL_ASGN:
		cclprintf(out, 0, "[&](");
		for (size_t i=0; i<e->decl_asgn.inits.valid; i++) {
			const struct cclerical_decl_asgn *da
				= &e->decl_asgn.inits.data[i];
			export_irram_var_decl(out, decls, da->id, 0);
			if (i+1 < e->decl_asgn.inits.valid)
				cclprintf(out, 0, ", ");
		}
		cclprintf(out, 0, "){\n");
		cclprintf(out, lvl+1, "%s", e->result_type == CCLERICAL_TYPE_UNIT ? "" : "return ");
		export_irram_expr(out, decls, e->decl_asgn.body, lvl+1);
		cclprintf(out, 0, ";\n");
		cclprintf(out, lvl, "}(");
		for (size_t i=0; i<e->decl_asgn.inits.valid; i++) {
			const struct cclerical_decl_asgn *da
				= &e->decl_asgn.inits.data[i];
			export_irram_expr(out, decls, da->init, lvl+1);
			if (i+1 < e->decl_asgn.inits.valid)
				cclprintf(out, 0, ", ");
		}
		cclprintf(out, 0, ")");
		break;
	case CCLERICAL_EXPR_VAR:
		cclprintf(out, 0, "%s%zu", CCL_PREFIX, e->var);
		break;
	case CCLERICAL_EXPR_FUN_CALL: {
		const struct cclerical_decl *d = decls->data[e->fun_call.fun];
		if (d->fun.body)
			cclprintf(out, 0, "%s%zu(", CCL_PREFIX, e->fun_call.fun);
		else
			cclprintf(out, 0, "cclerical::%s(", d->id);
		for (size_t i=0; i<e->fun_call.params.valid; i++) {
			export_irram_expr(out, decls, e->fun_call.params.data[i], lvl);
			cclprintf(out, 0, i+1 < e->fun_call.params.valid ? ", " : ")");
		}
		break;
	}
	case CCLERICAL_EXPR_OP:
		if (cclerical_op_is_unary(e->op.op)) {
			cclprintf(out, 0, "%s(", CCLERICAL_CPP_UOPS[e->op.op]);
			export_irram_expr(out, decls, e->op.args[0], lvl);
			cclprintf(out, 0, ")");
			break;
		} else if (e->op.op == CCLERICAL_OP_EXP) {
			cclprintf(out, 0, "power((");
			export_irram_expr(out, decls, e->op.args[0], lvl);
			cclprintf(out, 0, "), (");
			export_irram_expr(out, decls, e->op.args[1], lvl);
			cclprintf(out, 0, "))");
		} else {
			cclprintf(out, 0, "(");
			export_irram_expr(out, decls, e->op.args[0], lvl);
			cclprintf(out, 0, ") %s (", CCLERICAL_CPP_BOPS[e->op.op]);
			export_irram_expr(out, decls, e->op.args[1], lvl);
			cclprintf(out, 0, ")");
		}
		break;
	case CCLERICAL_EXPR_CASE:
		if (e->cases.valid > 2*6)
			DIE(2,"iRRAM backend does not support more than 6 cases\n");
		cclprintf(out, 0, "[&]{\n");
		cclprintf(out, lvl+1, "switch (iRRAM::choose(");
		for (size_t i=0; i<e->cases.valid; i++) {
			const struct cclerical_expr *f = e->cases.data[i].cond;
			export_irram_expr(out, decls, f, lvl+1);
			if (i+1 < e->cases.valid)
				cclprintf(out, 0, ", ");
		}
		cclprintf(out, 0, ")) {\n");
		cclprintf(out, lvl+1, "default: abort();\n");
		for (size_t i=0; i<e->cases.valid; i++) {
			const struct cclerical_expr *f = e->cases.data[i].body;
			cclprintf(out, lvl+1, "case %zu:\n", i+1);
			cclprintf(out, lvl+2, "%s", f->result_type == CCLERICAL_TYPE_UNIT ? "" : "return ");
			export_irram_expr(out, decls, f, lvl+2);
			cclprintf(out, 0, ";\n");
			if (f->result_type == CCLERICAL_TYPE_UNIT)
				cclprintf(out, lvl+2, "break;\n");
		}
		cclprintf(out, lvl+1, "}\n");
		cclprintf(out, lvl, "}()");
		break;
	case CCLERICAL_EXPR_IF:
		cclprintf(out, 0, "[&]{\n");
		cclprintf(out, lvl+1, "if (");
		export_irram_expr(out, decls, e->branch.cond, lvl);
		cclprintf(out, 0, ") {\n");
		cclprintf(out, lvl+2, "%s", e->branch.if_true->result_type == CCLERICAL_TYPE_UNIT ? "" : "return ");
		export_irram_expr(out, decls, e->branch.if_true, lvl+2);
		cclprintf(out, 0, ";\n");
		cclprintf(out, lvl+1, "}\n");
		if (e->branch.if_false) {
			cclprintf(out, lvl+1, "else {\n");
			cclprintf(out, lvl+2, "%s", e->branch.if_false->result_type == CCLERICAL_TYPE_UNIT ? "" : "return ");
			export_irram_expr(out, decls, e->branch.if_false, lvl+2);
			cclprintf(out, 0, ";\n");
			cclprintf(out, lvl+1, "}\n");
		}
		cclprintf(out, lvl, "}()");
		break;
	case CCLERICAL_EXPR_LIM: {
		vec_t prev_scope_vars = CCLERICAL_VECTOR_INIT;
		struct visit_prev_scope_args data = { &prev_scope_vars, e->lim.seq_idx };
		visit_varrefs_expr(decls, e->lim.seq, visit_prev_scope, &data);

		cclprintf(out, 0, "iRRAM::limit([](int p");
		for (size_t i=0; i<prev_scope_vars.valid; i++) {
			cclprintf(out, 0, ", ");
			export_irram_var_decl(out, decls, (uintptr_t)prev_scope_vars.data[i], 1);
		}
		cclprintf(out, 0, "){\n");
		cclprintf(out, lvl+1, "");
		export_irram_var_decl(out, decls, e->lim.seq_idx, 0);
		cclprintf(out, 0, " = -p;\n");
		cclprintf(out, lvl+1, "%s", e->lim.seq->result_type == CCLERICAL_TYPE_UNIT ? "" : "return ");
		export_irram_expr(out, decls, e->lim.seq, lvl+1);
		cclprintf(out, 0, ";\n");
		cclprintf(out, lvl, "}");
		for (size_t i=0; i<prev_scope_vars.valid; i++) {
			cclerical_id_t v = (uintptr_t)prev_scope_vars.data[i];
			cclprintf(out, 0, ", %s%zu", CCL_PREFIX, v);
		}
		cclprintf(out, 0, ")");

		cclerical_vector_fini(&prev_scope_vars);
		break;
	}
	/* these return Unit, no encapsulation into lambda-fun required */
	case CCLERICAL_EXPR_WHILE:
		cclprintf(out, 0, "while (");
		export_irram_expr(out, decls, e->loop.cond, lvl);
		cclprintf(out, 0, ") {\n");
		cclprintf(out, lvl+1, "%s", e->loop.body->result_type == CCLERICAL_TYPE_UNIT ? "" : "return ");
		export_irram_expr(out, decls, e->loop.body, lvl+1);
		cclprintf(out, 0, ";\n");
		cclprintf(out, lvl, "}");
		break;
	case CCLERICAL_EXPR_ASGN:
		cclprintf(out, 0, "%s%zu = ", CCL_PREFIX, e->asgn.var);
		export_irram_expr(out, decls, e->asgn.expr, lvl);
		//cclprintf(out, 0, ";\n");
		break;
	case CCLERICAL_EXPR_SKIP:
		cclprintf(out, 0, "/* skip */");
		break;
	case CCLERICAL_EXPR_SEQ:
		cclprintf(out, 0, "[&]");
		export_irram_prog(out, decls, e->seq, lvl);
		cclprintf(out, 0, "()");
		break;
	}
}

static void export_irram_prog(FILE *out,
                              const struct cclerical_vec_decl_ptr *decls,
                              const struct cclerical_prog *p, int lvl)
{
	cclprintf(out, 0, "{\n");
	for (size_t i=0; i<p->exprs.valid; i++) {
		struct cclerical_expr *e = p->exprs.data[i];
		cclprintf(out, lvl+1, "%s", (i+1 == p->exprs.valid
		                        && e->result_type != CCLERICAL_TYPE_UNIT)
		                       ? "return " : "");
		export_irram_expr(out, decls, e, lvl+1);
		cclprintf(out, 0, ";\n");
	}
	cclprintf(out, lvl, "}");
}

void export_irram(FILE *out,
                  const struct cc_opts *opts, const struct cclerical_input *input,
                  const struct cclerical_prog *p,
                  const struct cclerical_vec_decl_ptr *decls)
{
	(void)opts;
	(void)input;
	fprintf(out, "%s\n", IRRAM_HEADER);
	for (size_t i=0; i<decls->valid; i++) {
		struct cclerical_decl *d = decls->data[i];
		if (d->type != CCLERICAL_DECL_FUN)
			continue;
		export_irram_fun_decl(out, decls, i);
	}
	fprintf(out, "\n");
	for (size_t i=0; i<decls->valid; i++) {
		struct cclerical_decl *d = decls->data[i];
		if (d->type != CCLERICAL_DECL_FUN ||
		    cclerical_decl_fun_is_external(d))
			continue;
		export_irram_fun_sig(out, decls, i);
		fprintf(out, "\n");
		export_irram_prog(out, decls, d->fun.body, 0);
		fprintf(out, "\n\n");
	}
	fprintf(out, "void compute()\n");
	fprintf(out, "{\n");
	cclprintf(out, 1, "using iRRAM::cout;\n");
	cclprintf(out, 1, "cout << []");
	export_irram_prog(out, decls, p, 1);
	cclprintf(out, 0, "() << \"\\n\";\n");
	fprintf(out, "}\n");
//	printf("\tREAL vars[%zu];\n", decls->valid);
}
